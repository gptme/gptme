"""Tests for hook system integration in server API v2."""

import random
import time

import pytest

from gptme.hooks import HookType, register_hook, unregister_hook
from gptme.message import Message

# Skip if flask not installed
pytest.importorskip(
    "flask", reason="flask not installed, install server extras (-E server)"
)

from flask.testing import FlaskClient  # fmt: skip

pytestmark = [pytest.mark.timeout(30)]


def create_conversation(client: FlaskClient):
    """Create a V2 conversation with a session."""
    convname = f"test-hooks-{random.randint(0, 1000000)}"

    response = client.put(
        f"/api/v2/conversations/{convname}",
        json={"prompt": "You are a helpful assistant."},
    )

    assert response.status_code == 200
    data = response.get_json()
    assert data is not None
    assert "session_id" in data

    return {"conversation_id": convname, "session_id": data["session_id"]}


def test_session_start_hook(client: FlaskClient):
    """Test that SESSION_START hook is triggered for new conversations."""
    hook_triggered = []

    def session_start_hook(logdir, workspace, initial_msgs):
        hook_triggered.append("SESSION_START")
        yield Message("system", "SESSION_START hook triggered")

    # Register the hook
    register_hook("test_session_start", HookType.SESSION_START, session_start_hook)

    try:
        # Create a new conversation
        conv = create_conversation(client)

        # First, add a user message
        response = client.post(
            f"/api/v2/conversations/{conv['conversation_id']}",
            json={"role": "user", "content": "Hello"},
        )
        assert response.status_code == 200

        # Then call step to generate response (should trigger SESSION_START)
        response = client.post(
            f"/api/v2/conversations/{conv['conversation_id']}/step",
            json={
                "session_id": conv["session_id"],
                "stream": False,
            },
        )

        assert response.status_code == 200

        # Wait for step to complete (runs in background thread)
        time.sleep(3)

        # Get conversation log to verify hook message was added
        response = client.get(f"/api/v2/conversations/{conv['conversation_id']}")
        assert response.status_code == 200
        data = response.get_json()

        messages = data.get("log", [])

        # Debug: print all messages
        print(f"\nTotal messages: {len(messages)}")
        for i, m in enumerate(messages):
            print(
                f"Message {i}: role={m.get('role')}, content={m.get('content', '')[:100]}"
            )

        # Check if SESSION_START hook message is in the log
        hook_messages = [
            m
            for m in messages
            if "SESSION_START hook triggered" in m.get("content", "")
        ]
        assert (
            len(hook_messages) > 0
        ), f"SESSION_START hook message should be in log. Found {len(messages)} messages total"

        # Also verify the hook was triggered (via the list, though this is fragile due to threading)
        # We're mainly checking the log message above as the reliable indicator

    finally:
        # Clean up
        unregister_hook("test_session_start", HookType.SESSION_START)


def test_message_pre_process_hook(client: FlaskClient):
    """Test that MESSAGE_PRE_PROCESS hook is triggered before generation."""
    hook_triggered = []

    def pre_process_hook(manager):
        hook_triggered.append("MESSAGE_PRE_PROCESS")
        yield Message("system", "PRE_PROCESS hook triggered")

    # Register the hook
    register_hook("test_pre_process", HookType.MESSAGE_PRE_PROCESS, pre_process_hook)

    try:
        # Create a new conversation
        conv = create_conversation(client)

        # First, add a user message
        response = client.post(
            f"/api/v2/conversations/{conv['conversation_id']}",
            json={"role": "user", "content": "Say hello"},
        )
        assert response.status_code == 200

        # Then call step to generate response
        response = client.post(
            f"/api/v2/conversations/{conv['conversation_id']}/step",
            json={
                "session_id": conv["session_id"],
                "stream": False,
            },
        )

        assert response.status_code == 200

        # Wait for step to complete
        time.sleep(3)

        # Verify hook message was added
        response = client.get(f"/api/v2/conversations/{conv['conversation_id']}")
        assert response.status_code == 200
        data = response.get_json()

        messages = data.get("log", [])

        # Debug: print all messages
        print(f"\n=== PRE_PROCESS DEBUG: Total messages: {len(messages)} ===")
        for i, m in enumerate(messages):
            role = m.get("role", "?")
            content = m.get("content", "")[:100]
            print(f"  [{i}] {role}: {content}")

        hook_messages = [
            m for m in messages if "PRE_PROCESS hook triggered" in m.get("content", "")
        ]
        assert (
            len(hook_messages) > 0
        ), f"MESSAGE_PRE_PROCESS hook message should be in log. Found {len(messages)} messages"

    finally:
        # Clean up
        unregister_hook("test_pre_process", HookType.MESSAGE_PRE_PROCESS)


def test_message_post_process_hook(client: FlaskClient):
    """Test that MESSAGE_POST_PROCESS hook is triggered after generation."""
    hook_triggered = []

    def post_process_hook(manager):
        hook_triggered.append("MESSAGE_POST_PROCESS")
        yield Message("system", "POST_PROCESS hook triggered")

    # Register the hook
    register_hook("test_post_process", HookType.MESSAGE_POST_PROCESS, post_process_hook)

    try:
        # Create a new conversation
        conv = create_conversation(client)

        # First, add a user message
        response = client.post(
            f"/api/v2/conversations/{conv['conversation_id']}",
            json={"role": "user", "content": "Say hello"},
        )
        assert response.status_code == 200

        # Then call step to generate response
        response = client.post(
            f"/api/v2/conversations/{conv['conversation_id']}/step",
            json={
                "session_id": conv["session_id"],
                "stream": False,
            },
        )

        assert response.status_code == 200

        # Poll for hook message with timeout (handles different model speeds)
        max_wait = 10  # seconds (was 3)
        poll_interval = 0.5  # seconds
        hook_messages = []

        for attempt in range(int(max_wait / poll_interval)):
            time.sleep(poll_interval)

            # Fetch latest messages
            response = client.get(f"/api/v2/conversations/{conv['conversation_id']}")
            assert response.status_code == 200
            data = response.get_json()
            messages = data.get("log", [])

            # Check for hook message
            hook_messages = [
                m
                for m in messages
                if "POST_PROCESS hook triggered" in m.get("content", "")
            ]

            if len(hook_messages) > 0:
                print(
                    f"\n=== POST_PROCESS hook found after {(attempt + 1) * poll_interval}s ==="
                )
                break

        # Debug: print all messages if hook not found
        if len(hook_messages) == 0:
            print(f"\n=== DEBUG: Total messages in log: {len(messages)} ===")
            for i, m in enumerate(messages):
                role = m.get("role", "?")
                content = m.get("content", "")[:100]
                print(f"  [{i}] {role}: {content}")
        assert (
            len(hook_messages) > 0
        ), f"MESSAGE_POST_PROCESS hook message should be in log. Found {len(messages)} messages, searched for 'POST_PROCESS hook triggered'"

    finally:
        # Clean up
        unregister_hook("test_post_process", HookType.MESSAGE_POST_PROCESS)


def test_session_end_hook(client: FlaskClient):
    """Test that SESSION_END hook is triggered when last session is removed."""
    hook_triggered = []

    def session_end_hook(manager):
        hook_triggered.append("SESSION_END")
        yield Message("system", "SESSION_END hook triggered")

    # Register the hook
    register_hook("test_session_end", HookType.SESSION_END, session_end_hook)

    try:
        # Create a new conversation
        conv = create_conversation(client)
        session_id = conv["session_id"]

        # First, add a user message
        response = client.post(
            f"/api/v2/conversations/{conv['conversation_id']}",
            json={"role": "user", "content": "Hello"},
        )
        assert response.status_code == 200

        # Then call step to initialize the conversation
        response = client.post(
            f"/api/v2/conversations/{conv['conversation_id']}/step",
            json={
                "session_id": session_id,
                "stream": False,
            },
        )

        assert response.status_code == 200

        # Close the session (this should trigger SESSION_END since it's the only/last session)
        # Note: The actual cleanup might happen through SessionManager.remove_session
        # We need to check if there's an endpoint for this or if it happens automatically

        # For now, we'll verify the hook is registered correctly
        # The actual triggering happens in SessionManager.remove_session which is called
        # during cleanup/timeout operations

        # We can at least verify the hook doesn't error when called
        from gptme.logmanager import LogManager

        manager = LogManager.load(conv["conversation_id"], lock=False)

        # Manually trigger to test the hook works
        from gptme.hooks import trigger_hook

        list(trigger_hook(HookType.SESSION_END, manager=manager))

        assert "SESSION_END" in hook_triggered

    finally:
        # Clean up
        unregister_hook("test_session_end", HookType.SESSION_END)


def test_hooks_work_with_tools(client: FlaskClient):
    """Test that hooks work correctly when tools are executed."""
    pre_hook_triggered = []
    post_hook_triggered = []

    def pre_hook(manager):
        pre_hook_triggered.append("PRE")
        # Don't yield any message to keep it simple

    def post_hook(manager):
        post_hook_triggered.append("POST")
        # Don't yield any message to keep it simple

    # Register both hooks
    register_hook("test_pre", HookType.MESSAGE_PRE_PROCESS, pre_hook)
    register_hook("test_post", HookType.MESSAGE_POST_PROCESS, post_hook)

    try:
        # Create a new conversation
        conv = create_conversation(client)

        # First, add a user message
        response = client.post(
            f"/api/v2/conversations/{conv['conversation_id']}",
            json={"role": "user", "content": "Run: echo 'test'"},
        )
        assert response.status_code == 200

        # Then call step to generate response
        response = client.post(
            f"/api/v2/conversations/{conv['conversation_id']}/step",
            json={
                "session_id": conv["session_id"],
                "stream": False,
            },
        )

        assert response.status_code == 200

        # Wait for step to complete
        time.sleep(3)

        # We can't reliably check the hook_triggered lists due to threading,
        # but we can verify the hooks were registered and didn't error
        # The hooks should have been called even if we can't detect it via the list

    finally:
        # Clean up
        unregister_hook("test_pre", HookType.MESSAGE_PRE_PROCESS)
        unregister_hook("test_post", HookType.MESSAGE_POST_PROCESS)
